% !TeX root = ../index.tex

\section{Introduction}

\citeauthor{boner_reactive_2014} in their \citetitle{boner_reactive_2014} outline qualities of modern \glspl[]{is} that make them better to use and easier to develop, maintain and extend.
They summarize these qualities under the term \emph{reactive}.

In my work at SAP~SE, my team and I are building \gls[]{saas} business applications that are supposed to offer a great user experience, while being as cost-effective as possible to develop, operate, maintain and extend.
As a part of that effort we aim to make our product reactive by applying the microservice pattern and using asynchronous, message-based integration.
While applying these design paradigms to the implementation of business features we repeatedly encounter situations where the feature requires synchronous semantics for the communication between two microservices.

This requirement confronts us with a non-trivial design decision of how to best implement it in our system architecture that is dominated by asynchronous integration.
Various works in the professional literature examine the problem briefly but the solution approaches which they offer do not go into great detail \parencites[pp.~706--708]{millett_patterns_2015}[pp.~30--32]{stopford_designing_2018}[pp.~87--89]{richardson_microservices_2019}.
In academics, this particular problem has received no consideration so far.

The goal of this work is to create a generic concept for implementing synchronous semantics via an asynchronous medium that fulfills the requirements of being responsive, elastic and resilient.

To that end, the work follows the \gls[]{dsr} process outlined in \cite{alturki_design_2011}.
After section \ref{sec:method} provides a detailed discussion of the method, section \ref{sec:foundations} establishes necessary theoretical foundations.
Then section \ref{sec:problem} examines the problem space in greater detail before section \ref{sec:concept} derives a concept to address the problem, which is then evaluated in section \ref{sec:evaluation}.
Lastly, section \ref{sec:conclusion} discusses the results and concludes with an outlook on further work.

\clearpage
\section{Methodology}\label{sec:method}

This work aims to examine a practical problem that occurs within certain modern \glspl{is} and to provide a potential solution to it.
To that end, it follows the \gls[]{dsr} roadmap outlined by \cite[]{alturki_design_2011}.

First, section \ref{sec:problem} constructs an example \gls[]{is} architecture that implements a common business process using microservices and asynchronous communication.
This architecture serves as a basis for identifying the problem and research scope.
Furthermore, the requirements towards a solution are deduced from the examined scenario and alternative solutions are explored.

Section \ref{sec:concept} then proceeds to construct a concept for addressing the problem.
Due to the limited scope of this work, the created construct is only evaluated artificially without an actual implementation.

\clearpage
\section{Foundations}\label{sec:foundations}

\subsection{Reactive Information Systems}

\subsection{Microservice Architecture}

\subsection{Message-based Communication}

\clearpage
\section{Distributed Business Processes In Reactive Information Systems}\label{sec:problem}

This section examines the architecture of a hypothetical \gls{is} that implements a simplified version of the \gls{p2p} process.
The process describes the procurement of a company and is commonly implemented by \gls{erp} systems.
Since the process is commonplace, taking an \gls{is} that implements it as the basis for this work should result an artifact that is easily transferable to other \gls{is}.

\subsection{The Procure-to-Pay Process}

Figure \ref{fig:procure-to-pay} shows the distinct steps of the \gls{p2p} process.
On the procurement side, the process begins with a request.
For example, when an employee of a company requests a new stack of printing paper.
In this form of the process every request needs to be approved by a supervisor---a cost center manager for example.
An approved request can then be turned into an order by the company's purchasing department.
The order is then sent to the supplier.

\begin{figure}[h]
  \centering
  \includegraphics[width=0.9\textwidth]{procure-to-pay.drawio.png}
  \caption{The Procure-to-Pay Process}\label{fig:procure-to-pay}
\end{figure}

When the ordered goods are delivered to the company, the process continues on the payment side.
The goods are inspected and a goods receipt is created which is checked against the supplier's invoice.
If everything is in order, payment is made to the supplier.

To be as concise as possible, the sample \gls{is} architecture described by the following only includes the procurement part of the \gls{p2p} process.

\subsection{A Reactive Procurement Application}

Figure \ref{fig:example-architecture} shows the architecture of a reactive \gls{is} that implements the procurement part of the \gls{p2p} process.
The procurement domain is decomposed into three bounded contexts: Request, Order and Workflow.
Each sub-domain is implemented by a dedicated microservice.

The \gls{ui} is fragmented into a set of web-applications accessed by users via their internet browsers.
These fragments are not strictly separated by bounded context, but rather by use case, with the aim of providing a superior user experience.
For example, purchaser's may need to edit an employee's request to correct descriptions and prices because the employee's initial inputs were insufficient.

The microservices communicate asynchronously via a \gls{mom} with each other.
They read and write events to and from domain-specific topics within the \gls{mom}.
\todo{actually read ddd to make sure that you use these terms correctly}
\todo{explain rudimentary ddd together with microservices}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.9\textwidth]{architecture.drawio.png}
  \caption{The Example Architecture}\label{fig:example-architecture}
\end{figure}

In figure \ref{fig:example-architecture}, the different actors that interact with the \gls{is} in the context of the procurement process are shown at the top.
They interact with the system via the \gls{ui} fragments shown below as indicated by the arrows.
The fragments in turn interact with the microservices as indicated by the arrows.
Employees can request goods via the \emph{Requesting UI} and purchasers can edit requests as well as create orders via the \emph{Purchasing UI}.
Hence, the \emph{Purchasing UI} interacts with both the \emph{Request Service} and the \emph{Order Service}.
Requests are approved by managers via the \emph{Workflow UI} that interacts with the underlying \emph{Workflow Service}.
Although they are omitted in the diagram, each microservice is assumed to have a dedicated persistent storage.

The asynchronous communication of the microservices via the \gls{mom} is represented in figure \ref{fig:example-architecture} by the dashed arrows.
The \emph{Request Service} publishes events to the \emph{Requests} topic.
These events---in sum---contain all the information on all requests that exist in the system.
Therefore, the \emph{Order Service} replicates the requests by aggregating the events from the \emph{Requests}.
When an order is created via the \emph{Order Service}, it publishes an appropriate event to the \emph{Orders} topic.
From there, it could theoretically be consumed by other \glspl{is} to, for example, send the order to suppliers via mail or e-mail, or to reserve a budget in the company's accounts.
Finally, the \emph{Workflow Service} publishes to the \emph{Approvals} topic when a manager approves a request.
The \emph{Request Service} consumes these events to update the status of a request when it has been approved.
This status change is then replicated to the \emph{Order Service} so that purchaser can create an order for the request.

\subsection{Synchronous Communication in Asynchronous Information Systems}

The system architecture above is missing a crucial part.
Namely, how the workflow service is notified about new requests that need to be approved.
An easy way of achieving this would be for the \emph{Workflow Service} to also consume events from the \emph{Requests} topic.
In this way it would be notified when new requests are created and need to be approved.

While that is a simple solution, it is cumbersome to extend.
This becomes clear considering this hypothetical future requirement: Orders require a final approval before they are sent out to the supplier.
To address this requirement, the workflow service would need to listen to the \emph{Orders} topic as well.
The same would be true for any other business entity that might require approvals in the future.

Instead of the \emph{Workflow Service} picking up the required approvals from the other bounded contexts, the scheme can be inverted so that the bounded contexts tell the service when they require an approval.
This could be implemented by adding new topic \emph{Approval Requests} to the message broker and letting each domain that requires approvals publish events to it.
The \emph{Workflow Service} would consume and offer the approval requests to the appropriate users and publish events with the users' decisions to the \emph{Approvals} topic as it already does.
In this setup, the \emph{Workflow Service} and other bounded contexts fall into the traditional roles of server and clients.

The solution however is still missing an aspect.
Clients of the \emph{Workflow Service} need to know whether the service has received the approval request for a particular entity and properly processed it, so that they can provide accurate feedback to their users and know whether they should try to send the command again if it failed.
At this point the communication semantics become \emph{synchronous} because the clients need a reply from the server within a certain frame of time.


% Therefore, instead of only relying on what \cite[]{stopford_designing_2018} calls \emph{event choreography}, some \emph{event orchestration} needs to be introduced.
% \parencite[pp.~30--31]{stopford_designing_2018}

\clearpage
\section{Concept}\label{sec:concept}

\clearpage
\section{Evaluation}\label{sec:evaluation}

\clearpage
\section{Conclusion}\label{sec:conclusion}
